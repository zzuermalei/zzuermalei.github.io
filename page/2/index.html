<!DOCTYPE html>













<html class="theme-next muse" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
<meta property="og:type" content="website">
<meta property="og:title" content="小马同学的技术博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="小马同学的技术博客">
<meta property="og:description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小马同学的技术博客">
<meta name="twitter:description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">






  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>小马同学的技术博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小马同学的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Stay hungry. Stay Foolish. - Steve Jobs. 求知若渴，虚心若愚！</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/24/编译器王者-LLVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/24/编译器王者-LLVM/" itemprop="url">
                  编译器王者-LLVM
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-24 19:22:19" itemprop="dateCreated datePublished" datetime="2018-09-24T19:22:19+08:00">2018-09-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-03 17:26:10" itemprop="dateModified" datetime="2018-10-03T17:26:10+08:00">2018-10-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/编译原理/" itemprop="url" rel="index"><span itemprop="name">编译原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | LLVM | Objective-C</p>
<h1><span id="llvm-是什么">LLVM 是什么？</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/LLVM_Logo.svg" alt="LLVM-logo"></p>
<blockquote>
<p>The LLVM Project is a collection of modular and reusable compiler and toolchain technologies.<br>官网：<a href="https://llvm.org/" target="_blank" rel="noopener">https://llvm.org/</a></p>
</blockquote>
<p>LLVM 项目是模块化、可重用的编译器以及工具链技术的集合，美国计算机协会（ACM）将其2012年软件系统奖项颁给了LLVM，之前曾获得此奖项的软件和技术包括：Java、Apache、Mosaic、the World Wide Web、Smalltalk、UNIX、Eclipse等</p>
<p>创始人： Chris Lattner，亦是Swift之父</p>
<blockquote>
<ul>
<li>有些文章把 LLVM 当做 Low Level Virtual Machine（低级虚拟机）的缩写简称，官方描述如下:</li>
<li>The name “LLVM” itself is not an acronym; it is the full name of the project.<br>“LLVM” 不是首字母缩略词，它是项目的全称</li>
</ul>
</blockquote>
<h1><span id="传统的编译器架构">传统的编译器架构</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/传统编译器架构.png" alt="传统编译器架构"><br>传统编译器架构：</p>
<ul>
<li>Frontend：前端（词法分析、语法分析、语义分析、生成中间代码）</li>
<li>Optimizer：优化器（中间代码优化）</li>
<li>Backend：后端（生成对应平台、设备、架构机器码）</li>
</ul>
<h1><span id="llvm架构">LLVM架构</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/LLVM编译器架构.png" alt="传统编译器架构"><br>不同的前端后端使用统一的中间代码 LLVM Intermediate Representation（LLVM IR）</p>
<p>统一中间代码的优点：<br>1&gt; 如果需要支持一种新的编程语言，只需要实现一个新的前端<br>2&gt; 如果需要支持一种新的硬件设备，只需要实现一个新的后端<br>3&gt; 优化阶段是一个通用的阶段，它针对的是统一的 LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</p>
<p>相比之下，GCC 的前端和后端没有分的太开，前端后端耦合在一起。所以 GCC 为了支持一门新的语言，或者支持一个新的目标平台，就变得非常困难</p>
<p>LLVM 现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族、JAVA、.NET、Python、Ruby、Scheme、Haskell等）</p>
<h1><span id="clang">Clang</span></h1><p>1&gt; 什么是 Clang ?<br>Clang 是 LLVM 项目的一个子项目，基于 LLVM 架构 C/C++/Objective-C 的编译器前端</p>
<p>官网：<a href="http://clang.llvm.org/" target="_blank" rel="noopener">http://clang.llvm.org/</a></p>
<p>2&gt; 相比于 GCC，Clang 具有如下有点：<br><strong>编译速度快</strong>：在某些平台上，Clang 的编译速度显著的快过 GCC（Debug 模式下编译 OC 速度比 GCC 快 3 倍）<br><strong>占用内存小</strong>：Clang 生成的 AST(语法树) 所占用的内存是 GCC 的五分之一左右<br><strong>模块化设计</strong>：Clang 采用基于库的模块化设计，易于 IDE 继承及其他用途的作用<br><strong>诊断信息可读性强</strong>：在编译过程中，Clang 创建并保留了大量详细的元数据（metadata），有利于调试和错误定位<br><strong>设计清晰简单</strong>，容易理解，易于扩展增强</p>
<h1><span id="clang-与-llvm">Clang 与 LLVM</span></h1><p><img src="/2018/09/24/编译器王者-LLVM/Clang-LLVM_1.jpg" alt="传统编译器架构"><br><strong>广义的 LLVM</strong>：整个 LLVM 架构<br><strong>狭义的 LLVM</strong>：LLVM 后端（代码优化、目标代码生成等）</p>
<p><img src="/2018/09/24/编译器王者-LLVM/Clang-LLVM_2.png" alt="传统编译器架构"></p>
<h1><span id="oc源文件的编译过程">OC源文件的编译过程</span></h1><p><strong>命令行查看编译的过程</strong>：$ clang -ccc-print-phases main.m<br><img src="/2018/09/24/编译器王者-LLVM/OC源文件编译过程1.png" alt="OC源文件编译器过程1"><br>输入 main.m =&gt; 预处理器，预处理（include、import、宏定义…），输出 cpp 文件 =&gt; compiler 编译成中间代码 ir =&gt; 后端，目标代码 =&gt; 链接动态库等 =&gt; 适合 ** 架构的代码</p>
<p><strong>查看preprocessor（预处理）的结果</strong>：$ clang -E main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define AGE 30</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b + AGE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2018/09/24/编译器王者-LLVM/OC源文件编译过程1.png" alt="OC源文件编译过程2"><br>执行上面的命令行之后，发现预处理器将 &lt;stdio.h&gt; 中代码引了进来，而且将 AGE 宏 也替换成了 30</p>
<h1><span id="词法分析">词法分析</span></h1><p><strong>词法分析，生成 Token</strong>：$ clang -fmodules -E -Xclang -dump-tokens main.m<br><img src="/2018/09/24/编译器王者-LLVM/词法分析.png" alt="OC源文件编译过程2"><br>将代码中每个部分生成 token，’int’、’main’、’(‘、’int’、’argc’ …，一遍后面分析，Loc=<a href="main.m:13:9" target="_blank" rel="noopener">main.m:13:9</a>表示 main.m 13 行第 9 个字符</p>
<h1><span id="语法树-ast">语法树 - AST</span></h1><p><strong>语法分析，生成语法树（AST，Abstract Syntax Tree）</strong>：$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</p>
<p>词法分析之后将 Token 拼接、联系起来，生成语法树：<br><img src="/2018/09/24/编译器王者-LLVM/语法树.png" alt="OC源文件编译过程2"></p>
<h1><span id="llvm-ir">LLVM IR</span></h1><p>LLVM IR 有3中表示形式（但本质是等价的，就好比水可以有气体、液体、固体3中形态）</p>
<p><strong>1&gt;text</strong>：便于阅读的文本格式，类似于汇编语言，扩展名 .ll，$ clang -S -emit-llvm main.m<br><strong>2&gt;memory</strong>：内存格式<br><strong>3&gt;bitcode</strong>：二进制格式，扩展名 .bc，$ clang -c -emit-llvm main.m</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码生成 text 格式中间代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">define <span class="keyword">void</span> @test(i32, i32) <span class="meta">#0 &#123;</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int a </span></span><br><span class="line">    %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int b</span></span><br><span class="line">    %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 定义一个局部变量 int c</span></span><br><span class="line">    %<span class="number">5</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 将 0（第一个参数）的值赋给 3，即 a</span></span><br><span class="line">    store i32 %<span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 将 1（第二个参数）的值赋给 4，即 b</span></span><br><span class="line">    store i32 %<span class="number">1</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 读取 3 的值给 6，即 a</span></span><br><span class="line">    %<span class="number">6</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 读取 4 的值给 7，即 b</span></span><br><span class="line">    %<span class="number">7</span> = load i32, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">    <span class="comment">// 6 + 7，即 a + b，给 8</span></span><br><span class="line">    %<span class="number">8</span> = add nsw i32 %<span class="number">6</span>, %<span class="number">7</span></span><br><span class="line">    <span class="comment">// 8 - 3，即 a + b - 3</span></span><br><span class="line">    %<span class="number">9</span> = sub nsw i32 %<span class="number">8</span>, <span class="number">3</span></span><br><span class="line">    <span class="comment">// 将 a + b - 3 的结果给 5，即 c，即 c = a + b - 3</span></span><br><span class="line">    store i32 %<span class="number">9</span>, i32* %<span class="number">5</span>, align <span class="number">4</span></span><br><span class="line">    ret <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>IR 基本语法:</strong><br>1&gt; 注释以分号<strong> ;</strong> 开头<br>2&gt; 全局标识符以<strong>@</strong>开头，局部标识符以<strong>%</strong>开头<br>3&gt; <strong>alloca</strong>，在当前函数栈帧中分配内存<br>4&gt; <strong>i32</strong>，32bit，4个字节的意思<br>5&gt; <strong>align</strong>，内存对齐<br>6&gt; <strong>store</strong>，写入数据<br>7&gt; <strong>load</strong>，读取数据</p>
<p>官方语法参考：<br><a href="https://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">https://llvm.org/docs/LangRef.html</a></p>
<hr>
<p>上面带大家简单熟悉了下 LLVM，感兴趣的童鞋可以进入官网自行深入研究。光了解是不是有点无趣呢，接下来，我们来开发一个我们自己的编译器插件</p>
<h1><span id="llvm-clang-源码下载">LLVM、Clang 源码下载</span></h1><p>下载LLVM<br>\$ <a href="https://git.llvm.org/git/llvm.git/" target="_blank" rel="noopener">https://git.llvm.org/git/llvm.git/</a><br>大小 661.3 M，仅供参考</p>
<p>下载clang<br>\$ cd llvm/tools<br>$ git clone <a href="https://git.llvm.org/git/clang.git/" target="_blank" rel="noopener">https://git.llvm.org/git/clang.git/</a><br>大小 242.9 M，仅供参考</p>
<h1><span id="源码编译">源码编译</span></h1><p>我们在终端可以敲 clang 命令，是因为在 Xcode …/XcodeDefault.xctoolchain/user/bin目录下已经安装了Clang，并且MAC 默认用的是 Xcode 内置的 Clang。既然我们要开发自己的编译器插件，所以在源码下载完成之后，我们需要编译我们自己的 Clang</p>
<p><strong>安装 cmake 和 ninja</strong>（先安装brew，<a href="https://brew.sh" target="_blank" rel="noopener">https://brew.sh</a>）<br>1&gt; $ brew install cmake<br>2&gt; $ brew install ninja</p>
<p><strong>注</strong>：ninja 如果安装失败，可以直接从 github 获取 release 版放入 <strong>/usr/local/bin</strong>中，<a href="https://github.com/ninja-build/ninja/releases" target="_blank" rel="noopener">https://github.com/ninja-build/ninja/releases</a></p>
<hr>
<p>在LLVM源码统计目录下新建一个 <strong>llvm_build</strong>目录（最终会在 <strong>llvm_build</strong> 目录下生成 <strong>build.ninja</strong>）</p>
<p>/LLVM_ALL/llvm<br>/LLVM_ALL/llvm_build<br>/LLVM_ALL/llvm_release<br>/LLVM_ALL/llvm_xcode</p>
<p><strong>$ cd llvm_build</strong><br><strong>$ cmake -G Ninja ../llvm</strong>(指定 llvm 源码位置，会将 llvm 源码在llvm_build 目录下生成 ninja 的模板，注：llvm 路径需根据自己的 llvm 目录相对于 llvm_build 的位置) <strong>成功的标识</strong>：llvm_build 目录下生成 build.ninja 文件</p>
<p><strong>指定LLVM编译目标路径：</strong><br><strong>$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径</strong><br>(eg.)  $ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=/users/<em>username</em>/Desktop/项目/LLVM_ALL/llvm_release/</p>
<p>更多 cmake 相关选项，可以参考：<a href="https://llvm.org/docs/CMake.html" target="_blank" rel="noopener">https://llvm.org/docs/CMake.html</a></p>
<hr>
<p>依次执行编译、安装指令<br><strong>$ ninja</strong><br>编译完毕后， <strong>llvm_build</strong> 目录大概 21.61 G（仅供参考）<br><strong>$ ninja install</strong><br>安装完毕后，安装目录大概 12.21 G（仅供参考）</p>
<hr>
<p>生成 Xcode 模板工程，使用 Xcode 进行编译<br><strong>$ cd llvm_xcode</strong><br><strong>$ cmake -G Xcode ../llvm</strong></p>
<h1><span id="应用与实践">应用与实践</span></h1><p>1&gt; libclang、libTooling<br>官方参考：<a href="https://clang.llvm.org/docs/Tooling.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/Tooling.html</a><br>应用：<strong>语法树分析</strong>、<strong>语言转换</strong>等</p>
<p>2&gt; Clang 插件开发<br>官方参考：<br><a href="https://clang.llvm.org/docs/" target="_blank" rel="noopener">https://clang.llvm.org/docs/</a><br><a href="https://clang.llvm.org/docs/ClangPlugins.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ClangPlugins.html</a><br><a href="https://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/ExternalClangExamples.html</a><br><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/RAVFrontendAction.html</a><br>应用：<strong>代码检查（命名规范、代码规范）</strong>等</p>
<p>3&gt; Pass开发<br>官方参考：<a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">http://llvm.org/docs/WritingAnLLVMPass.html</a><br>应用：<strong>代码优化</strong>、<strong>代码混淆</strong>等</p>
<p>4&gt; 开发新的编程语言<br><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a><br><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/18/Category/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/18/Category/" itemprop="url">
                  Category
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-18 23:08:48" itemprop="dateCreated datePublished" datetime="2018-09-18T23:08:48+08:00">2018-09-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:26:38" itemprop="dateModified" datetime="2018-09-24T22:26:38+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | Category | Objective-C</p>
<p>Category的实现原理？Category和Class Extension的区别是什么？Category中的load方法时什么时候调用的？如何给分类添加属性？</p>
<hr>
<p>通过前面章节，我们有学习到OC实例方法存储在class对象里面，类方法存储在meta-class里面，那么分类里面方法呢，难道是一个新的对象来进行存储么？</p>
<p>答案肯定是否，<strong>class对象、meta-class对象在内存中只会存在一份，分类里面的方法会合并到class对象、meta-class中</strong>。</p>
<h2><span id="1category的实现原理">1.Category的实现原理</span></h2><p>Category内方法是什么时候合并到class、meta-class对象中的，是在编译阶段么？</p>
<p>并不是，是在程序运行时通过runtime机制动态将分类的方法合并到class、meta-class对象中。下面来通过探索源码来进行分析验证。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Test_A</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)testA;</span><br><span class="line">- (<span class="keyword">void</span>)testA;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Test_A</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)testA &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)testA &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>通过clang编译器将 Person+Test_A.m 文件转成cpp文件，搜索 struct _category_t {<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> _category_t &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">struct</span> _class_t *cls;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *instance_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _method_list_t *class_methods;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _protocol_list_t *protocols;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">struct</span> _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Person+Test_A这个分类在编译完，转成上面这种结构，Test_A分类里面的方法、协议、属性信息也是存储在这个结构体中。每编写一个分类，就相当于一个 struct _category_t 类型的结构体，在程序运行时，通过runtime机制动态的将这个结构体内部的方法、协议等合并到类对象中。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/KVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/KVC/" itemprop="url">
                  KVC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-11 23:37:08" itemprop="dateCreated datePublished" datetime="2018-09-11T23:37:08+08:00">2018-09-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:26:28" itemprop="dateModified" datetime="2018-09-24T22:26:28+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | KVC | Objective-C</p>
<p>通过KVC修改属性会不会触发KVO，KVC底层实现是什么样子？</p>
<h2><span id="1kvc">1.KVC</span></h2><p>KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问某个属性</p>
<p>常见API:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure></p>
<h2><span id="2通过kvc修改属性会触发kvo么">2.通过KVC修改属性会触发KVO么</span></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Observer</span></span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line"></span><br><span class="line">[person addObserver:observer forKeyPath:<span class="string">@"age"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[person setValue:@<span class="number">20</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line"></span><br><span class="line">[person removeObserver:observer forKeyPath:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure>
<p>通过控制台输出，发现是可以触发KVO的</p>
<h2><span id="3setvalueforkey">3.setValue:forKey</span></h2><p><img src="/2018/09/11/KVC/setValueForKey.png" alt="setValue:forKey:"><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person setValue:@<span class="number">20</span> forKey:<span class="string">@"age"</span>];</span><br></pre></td></tr></table></figure></p>
<p>上面这行代码相当于下面这几行，在对属性赋值的时候系统内部会自动调用 willChangeValueForKey 和 didChangeValueForKey，所以会触发 KVO，可以重写这两个方法进行验证。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[person willChangeValueForKey:<span class="string">@"age"</span>];</span><br><span class="line">person-&gt;_age = <span class="number">20</span>;</span><br><span class="line">[person didChangeValueForKey:<span class="string">@"key"</span>];</span><br></pre></td></tr></table></figure></p>
<h2><span id="4valueforkey">4.valueForKey</span></h2><p><img src="/2018/09/11/KVC/setValueForKey.png" alt="valueForKey:"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/iOS中的线程同步方案-锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/iOS中的线程同步方案-锁/" itemprop="url">
                  iOS中的线程同步方案（锁）、读写安全方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-06 08:42:11" itemprop="dateCreated datePublished" datetime="2018-09-06T08:42:11+08:00">2018-09-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:15:30" itemprop="dateModified" datetime="2018-09-11T23:15:30+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="ios中的线程同步方案">iOS中的线程同步方案</span></h1><ul>
<li>OSSpinLock</li>
<li>os_unfair_lock</li>
<li>pthread_mutex</li>
<li>dispatch_semaphore</li>
<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>NSCondition</li>
<li>NSConditionLock</li>
<li>@synchronized</li>
</ul>
<h1><span id="1osspinlock">1.OSSpinLock</span></h1><p>1&gt; OSSpinLock叫做“自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源；High-level lock，高级锁，等不到锁时忙等，不会休眠<br>2&gt; 目前已经不再安全，可能会出现优先级反转问题<br>3&gt; 如果等待锁的优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁<br>4&gt; 需要导入头文件 #import <strong>&lt;libkern/OSAtomic.h&gt;</strong></p>
<p><strong>自旋锁优先级反转：</strong>有两个线程，thread1（高优先级）、thread2（低优先级），thread2先进行加锁操作，CPU切换调度，thread1进入，发现已经被锁，进入自旋状态。由于thread1优先级比thread2高出很多，CPU接下来可能一直调度thread1，处于自旋状态，相当于一直执行不到thread2的解锁操作，造成优先级反转现象</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">OSSpinLock lock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）</span></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">OSSpinLockLock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">OSSpinLockUnlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>OSSpinLock是性能最高的锁，因为加锁操作耗时较短的话，忙等一会儿直接继续执行了；反之休眠的话唤醒也是需要耗性能的。但是现在已经不再安全了，所以苹果不建议我们再继续使用OSSpinLock了</p>
<p>验证<strong>OSSpinLock自旋锁忙等</strong>：<br>Xcode -&gt; Debug Workflow -&gt; Always show Disassembly</p>
<p>step:：代码级别一行一行走<br>stepi：汇编指令一行一行走，简称 si<br>nexti：汇编指令一行一行走，但是如果遇到函数调用不会进去，会直接跳过</p>
<p>我们通过 si 指令，一行一行走，进入 OSSpinLockLock 函数，继续，进入 _OSSpinLockLockSlow 函数，这个时候要注意了：会一直在一块儿内存地址代码之间重复执行，这种就是典型的while循环，自旋锁，只有锁被放开之后才会往下继续执行</p>
<h1><span id="2os_unfair_lock_lock">2.os_unfair_lock_lock</span></h1><p>1&gt; os_unfair_lock用于取代不安全的OSSpinLock，从iOS10开始支持<br>2&gt; 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等；Low-level lock,低级锁，等不到锁时休眠<br>3&gt; 需要导入头文件 #import <strong>&lt;os/lock.h&gt;</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">os_unfair_lock_trylock(&amp;lock);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">os_unfair_lock_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<p>验证 <strong>os_unfair_lock_lock 非忙等</strong>：<br>os_unfair_lock_lock -&gt; _os_unfair_lock_lock_slow -&gt; __ulock_wait，进入之后，发现断点过着过着、到syscall时直接过去了，直接休眠了，这也说明os_unfair_lock_lock线程等待时并非忙等，而是休眠了</p>
<h1><span id="3-pthread_mutex">3. pthread_mutex</span></h1><p>1&gt; mutex叫做“互斥锁”，等待锁的线程会处于休眠状态<br>2&gt; 需导入头文件 #import <strong>&lt;pthread.h&gt;</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Mutex type attributes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 普通锁</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_NORMAL        0</span></span><br><span class="line"><span class="comment">// 检查错误的</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_ERRORCHECK    1</span></span><br><span class="line"><span class="comment">// 递归锁</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_RECURSIVE        2</span></span><br><span class="line"><span class="meta">#define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁的属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 尝试加锁</span></span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="comment">// 销毁相关资源</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure></p>
<p>将属性attr的type由PTHREAD_MUTEX_NORMAL改为 PTHREAD_MUTEX_RECURSIVE，这个锁就变成了递归锁：允许 <strong>同一个线程</strong> 对 <strong>同一把锁</strong> 进行 <strong>重复加锁</strong></p>
<h1><span id="4pthread_mutex-递归锁">4.pthread_mutex - 递归锁</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr);</span><br></pre></td></tr></table></figure>
<h1><span id="5pthread_mutex-条件">5.pthread_mutex - 条件</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line"><span class="comment">// NULL代表使用默认属性</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 初始化条件</span></span><br><span class="line">pthread_cond_t condition;</span><br><span class="line">pthread_cond_init(&amp;condition, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</span></span><br><span class="line">pthread_cond_wait(&amp;condition, &amp;mutex);</span><br><span class="line"><span class="comment">// 激活一个等待该条件的线程</span></span><br><span class="line">pthread_cond_signal(&amp;condition);</span><br><span class="line"><span class="comment">// 激活所有等待该条件的线程</span></span><br><span class="line">pthread_cond_broadcast(&amp;condition);</span><br><span class="line"><span class="comment">// 销毁资源</span></span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">pthread_cond_destroy(&amp;condition);</span><br></pre></td></tr></table></figure>
<h1><span id="6nslock-nsrecurisivelock">6.NSLock、NSRecurisiveLock</span></h1><p>1&gt; NSLock 是对mutex普通锁的封装<br>2&gt; NSRecursiveLock 也是对mutex递归锁的封装，API跟NSLock基本一致<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt;</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>NSLock 是OC对象，再从堆栈一行一行找的话不好看锁的执行流程，因为OC对象通过消息机制执行方法，堆栈里面有很多消息机制流程，对汇编不是很熟悉的话不好断点。</p>
<p>那我们就放弃了么，NO，NO，还是可以通过 <strong><a href="http://ftpmain.gnustep.org/pub/gnustep/core/gnustep-base-1.25.0.tar.gz" target="_blank" rel="noopener">GUNStep -&gt; GNUstep Base</a></strong> 来参考下</p>
<p>GNUstep是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍，虽然GNUstep不是苹果官方源码，但还是具有一定的参考价值</p>
<p>源码地址：<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">http://www.gnustep.org/resources/downloads.php</a></p>
<p>下载之后打开工程，搜索 <strong>NSLock.m</strong>，找到 <strong>initialize</strong> 方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">BOOL</span>    beenHere = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beenHere == <span class="literal">NO</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        beenHere = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Initialise attributes for the different types of mutex.</span></span><br><span class="line"><span class="comment">        * We do it once, since attributes can be shared between multiple</span></span><br><span class="line"><span class="comment">        * mutexes.</span></span><br><span class="line"><span class="comment">        * If we had a pthread_mutexattr_t instance for each mutex, we would</span></span><br><span class="line"><span class="comment">        * either have to store it as an ivar of our NSLock (or similar), or</span></span><br><span class="line"><span class="comment">        * we would potentially leak instances as we couldn't destroy them</span></span><br><span class="line"><span class="comment">        * when destroying the NSLock.  I don't know if any implementation</span></span><br><span class="line"><span class="comment">        * of pthreads actually allocates memory when you call the</span></span><br><span class="line"><span class="comment">        * pthread_mutexattr_init function, but they are allowed to do so</span></span><br><span class="line"><span class="comment">        * (and deallocate the memory in pthread_mutexattr_destroy).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pthread_mutexattr_init(&amp;attr_normal);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_normal, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">        pthread_mutexattr_init(&amp;attr_reporting);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_reporting, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">        pthread_mutexattr_init(&amp;attr_recursive);</span><br><span class="line">        pthread_mutexattr_settype(&amp;attr_recursive, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* To emulate OSX behavior, we need to be able both to detect deadlocks</span></span><br><span class="line"><span class="comment">        * (so we can log them), and also hang the thread when one occurs.</span></span><br><span class="line"><span class="comment">        * the simple way to do that is to set up a locked mutex we can</span></span><br><span class="line"><span class="comment">        * force a deadlock on.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pthread_mutex_init(&amp;deadlock, &amp;attr_normal);</span><br><span class="line">        pthread_mutex_lock(&amp;deadlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，其实就是 <strong>pthread_mutex_init(&amp;deadlock, &amp;attr_normal);</strong>，所以 NSLock 其实就是对 pthread_mutex 普通锁的封装</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSRecursiveLock</span></span><br><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_recursive))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="7nscondition">7.NSCondition</span></h1><p>1&gt; NSCondition是对mutex和cond的封装<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSCondition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="keyword">void</span>)signal;</span><br><span class="line">- (<span class="keyword">void</span>)broadcast;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>GNUStep实现如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != pthread_cond_init(&amp;_condition, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != pthread_mutex_init(&amp;_mutex, &amp;attr_reporting))</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_destroy(&amp;_condition);</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) signal</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) wait</span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_condition, &amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="8nsconditionlock">8.NSConditionLock</span></h1><p>1&gt; NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>GUNStep：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithCondition: <span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>) initWithCondition: (<span class="built_in">NSInteger</span>)value</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nil</span> != (<span class="keyword">self</span> = [<span class="keyword">super</span> init]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nil</span> == (_condition = [<span class="built_in">NSCondition</span> new]))</span><br><span class="line">        &#123;</span><br><span class="line">            DESTROY(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _condition_value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="9dispatch_queuedispatch_queue_serial-gcd串行队列">9.dispatch_queue(DISPATCH_QUEUE_SERIAL) GCD串行队列</span></h1><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"top.istones.moneyQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.moneyQueue, ^&#123;</span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1><span id="10dispatch_semaphore">10.dispatch_semaphore</span></h1><p>1&gt; semaphore叫做”信号量”<br>2&gt; 信号量的初始值，可以用来控制线程并发访问的最大数量<br>3&gt; 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量的初始值</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(value);</span><br><span class="line"><span class="comment">// 如果信号量的值 &lt;= 0，当前线程进入休眠等待（直到信号量的值 &gt; 0）</span></span><br><span class="line"><span class="comment">// 如果信号量的值 &gt; 0，就减1，然后往下执行后面的代码</span></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">// 信号量的值加1</span></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure>
<h1><span id="11synchronized">11.@synchronized</span></h1><p>1&gt; @synchronized是对mutex递归锁的封装<br>2&gt; 源码查看：<strong>objc4</strong>中的<strong>objc-sync.mm</strong>文件<br>3&gt; @synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(obj) &#123; <span class="comment">// objc_sync_enter</span></span><br><span class="line">    <span class="comment">// 任务</span></span><br><span class="line">&#125; <span class="comment">// objc_sync_exit</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>效率非常低，苹果已经不推荐使用，Xcode也没有提示了</p>
<p>Xcode断点，发现，@synchronized在大括号进入和退出时分别调用的是 objc_sync_enter 和 objc_sync_exit。在 objc-sync.mm 文件中搜索：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="keyword">int</span> objc_sync_enter(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="keyword">int</span> objc_sync_exit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1><span id="性能">性能</span></h1><p>性能由高到低：<br>1&gt; os_unfair_lock<br>2&gt; OSSpinLock<br>3&gt; dispatch_semaphore<br>4&gt; pthread_mutex<br>5&gt; dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>6&gt; NSLock<br>7&gt; NSCondition<br>8&gt; pthread_mutex(recursive)<br>9&gt; NSRecursiveLock<br>10&gt; NSConditionLock<br>11&gt; @synchronized</p>
<p>推荐使用 dispatch_semaphore、pthread_mutex，os_unfair_lock 性能虽然高，但是从 iOS10 才开始支持</p>
<h1><span id="什么情况下使用自旋锁比较划算">什么情况下使用自旋锁比较划算</span></h1><p>1&gt; 预计线程等待锁的时间很短<br>2&gt; 加锁的代码（临界区）经常被调用，但竞争很少发生<br>3&gt; CPU 资源不紧张<br>4&gt; 多核处理器</p>
<h1><span id="什么情况下使用互斥锁比较划算">什么情况下使用互斥锁比较划算</span></h1><p>1&gt; 预计线程等待锁的时间较长<br>2&gt; 单核处理器<br>3&gt; 临界区有IO操作<br>4&gt; 临界区代码复杂或者循环量大<br>5&gt; 临界区竞争非常激烈</p>
<hr>
<h1><span id="atomic">atomic</span></h1><p>1&gt; atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁<br>2&gt; 可以参考源码 <strong>objc4</strong> 的 <strong>objc-accessors.mm</strong><br>3&gt; 它并不能保证使用属性的过程是线程安全的（eg.一个属性array，atomic的话只能保证在外面set和get的时候线程安全，但是不能保证array addObject、removeObject线程安全）</p>
<p>提到 atomic，我们想到更多的是 nonatomic，atomic 原子性，在 macOS 中有用，在 iOS 项目中几乎不会用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">nonatomic 和 atomic</span></span><br><span class="line"><span class="comment">atom：原子</span></span><br><span class="line"><span class="comment">atomic：原子性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">给属性加上atomic属性修饰，可以保证属性的setter和getter都是原子性操作，也就是保证setter和getter内部都是线程同步的，相当于下面：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- (void)setName:(NSString *)name &#123;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">    _name = name;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- (NSString *)name &#123;</span></span><br><span class="line"><span class="comment">    // 加锁</span></span><br><span class="line"><span class="comment">    // 取值</span></span><br><span class="line"><span class="comment">    // 解锁</span></span><br><span class="line"><span class="comment">    // 返回</span></span><br><span class="line"><span class="comment">    return _name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>打开objc4源码，搜索 <strong>objc-accessors.mm</strong> 文件，观察 reallySetProperty 和 objc_getProperty 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，如果是atomic，就加了一把<strong>自旋锁</strong>，如果是nonatomic，直接set或返回值</p>
<hr>
<h1><span id="ios中的读写安全方案">iOS中的读写安全方案</span></h1><p>我们先思考如何实现以下场景：<br>1&gt; 同一时间，只能有1个线程进行写的操作<br>2&gt; 同一时间，允许有多个线程进行读的操作<br>3&gt; 同一时间，不允许既有写的操作，又有读的操作</p>
<p>上面的场景就是典型的“多读单写”，经常用于文件等数据的读写操作</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(read) object:<span class="literal">nil</span>] start];</span><br><span class="line">        [[[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(write) object:<span class="literal">nil</span>] start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - private methods</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">如果读也加上 semaphore 的话，确实可以保证读写都安全，同时只能读或者写，但是没必要。iOS中读写方案一般设计多读单写，读不涉及资源抢占，可以同时进行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">但是，这样依然存在问题，虽然可以多读单写。但是写入加锁了，读却没有加锁，读的同时依然可以写，这个依然不可控，依然不安全，不能保证读的同时没有线程在进行写的操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line"><span class="comment">//    dispatch_semaphore_wait(self.semphore, DISPATCH_TIME_FOREVER);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    dispatch_semaphore_signal(self.semphore);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">    dispatch_semaphore_wait(<span class="keyword">self</span>.semphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_signal(<span class="keyword">self</span>.semphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像简单这样用semphore的话并不能实现安全多读单写，那么怎么实现呢？</p>
<p>iOS中的实现方案有：<br>1&gt; pthread_rwlock：读写锁<br>2&gt; dispatch_barrier_async：异步栅栏调用</p>
<h4><span id="pthread_rwlock">pthread_rwlock</span></h4><p>等待锁的线程会进入休眠<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 读-加锁</span></span><br><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 读-尝试加锁</span></span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-加锁</span></span><br><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 写-尝试加锁</span></span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">pthread_rwlock_destroy(&amp;lock);</span><br></pre></td></tr></table></figure></p>
<h4><span id="dispatch_barrier_async">dispatch_barrier_async</span></h4><p>1&gt; 这个函数传入的并发队列必须是自己通过dispatch_queue_cretate创建的<br>2&gt; 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于dispatch_async函数的效果</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"top.istones.rwQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写</span></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>读和写一定要放到一个队列里面！</p>
<p><a href="/download/线程同步方案/线程同步方案.zip"><strong>本文demo</strong></a><br><a href="/download/1.OC对象的本质/objc4-723.tar.gz"><strong>objc4</strong></a><br><a href="/download/线程同步方案/gnustep-base-1.25.0.zip"><strong>GNUstep Base</strong></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/深入理解KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/深入理解KVO/" itemprop="url">
                  深入理解KVO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-04 00:52:07" itemprop="dateCreated datePublished" datetime="2018-09-04T00:52:07+08:00">2018-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-24 22:23:00" itemprop="dateModified" datetime="2018-09-24T22:23:00+08:00">2018-09-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | KVO | Objective-C</p>
<h2><span id="kvo的本质是什么如何手动触发kvo">KVO的本质是什么，如何手动触发KVO？</span></h2><hr>
<h2><span id="1什么是kvo">1.什么是KVO</span></h2><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变</p>
<p>添加监听:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="built_in">NSKeyValueObservingOptions</span> : <span class="built_in">NSUInteger</span> &#123;</span><br><span class="line">    <span class="comment">// 新值（包含于回调方法change字典中）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionNew</span> = <span class="number">0x01</span>,</span><br><span class="line">    <span class="comment">// 旧值（包含于回调方法change字典中）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionOld</span> = <span class="number">0x02</span>,</span><br><span class="line">    <span class="comment">// 观察最初的值（在注册观察服务时会调用一次触发方法）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionInitial</span> = <span class="number">0x04</span>,</span><br><span class="line">    <span class="comment">// 分别在值修改前后触发方法（即一次修改有两次触发）</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptionPrior</span> = <span class="number">0x08</span></span><br><span class="line">&#125; <span class="built_in">NSKeyValueObservingOptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">监听属性方法，方法调用者为被观察对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@param observer 观察者/订阅者</span></span><br><span class="line"><span class="comment">@param keyPath  要观察的属性 </span></span><br><span class="line"><span class="comment">@param options  监听变化条件</span></span><br><span class="line"><span class="comment">@param context  上下文，将会传递到监听回调函数中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>监听回调：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object change:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="keyword">id</span>&gt; *)change context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>移除监听：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br></pre></td></tr></table></figure></p>
<p>KVO使用大家都比较熟悉，Demo应该就没有写的必要了，下面我们直接来探索下本质</p>
<h2><span id="2kvo的本质">2.KVO的本质</span></h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.person1 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.person2 = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之前：Person, Person</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前：%@, %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之前 setter 方法：0x10d2fb550, 0x10d2fb550</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前 setter 方法：%p, %p"</span>,</span><br><span class="line">    [<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">    [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之后：NSKVONotifying_Person, Person</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之前：%@, %@"</span>, object_getClass(<span class="keyword">self</span>.person1), object_getClass(<span class="keyword">self</span>.person2));</span><br><span class="line">    <span class="comment">// 输出 &gt;&gt; 监听之后 setter 方法：0x10d643bf4, 0x10d2fb550</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听之后 setter 方法：%p, %p"</span>,</span><br><span class="line">    [<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">    [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (lldb)po ([NSKVONotifying_Person class]).superclass Person</span></span><br><span class="line">    <span class="comment">// (lldb) p (IMP)0x10d2fb550 (IMP) $0 = 0x000000010d2fb550 (KVO与KVC`-[Person setAge:] at Person.h:13)</span></span><br><span class="line">    <span class="comment">// (lldb) p (IMP)0x10d643bf4 (IMP) $1 = 0x000000010d643bf4 (Foundation`_NSSetLongLongValueAndNotify)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到：%@ 的：%@ 属性值改变了，change：%@ - context：%@"</span>, object, keyPath, change, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过断点调试，我们发现 person2 的类对象没有发生变化，person1 的类对象变成了 NSKVONotifying_Person，而且是Person的子类。</strong></p>
<p>使用 Runtime 打印 NSKVONotifying_Person 方法列表：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methCount = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *methodArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    Method *meths = class_copyMethodList(cls, &amp;methCount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methCount; i++) &#123;</span><br><span class="line">        Method meth = meths[i];</span><br><span class="line">        SEL sel = method_getName(meth);</span><br><span class="line">        <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">        [methodArr addObject:methodName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methodArr.count) <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, methodArr);</span><br><span class="line">    free(meths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>NSKVONotifying_Person 实例方法列表：<ul>
<li>setAge:</li>
<li>class</li>
<li>dealloc</li>
<li>_isKVOA</li>
</ul>
</li>
</ul>
<p>总结：<br>1&gt; 添加监听时，利用RuntimeAPI动态生成Person子类： NSKVONotifying_Person ，并且使 person1 的 isa 指针指向新的类<br>2&gt; 重写 setAge: ，person1 调用 setter 方法时会从 NSKVONotifying_Person 开始查找，在自己的类对象中能够找到，所以会调用自己的 setAge：方法（ 会调用Foundation的_NSSet<strong><em>ValueAndNotify函数）<br>3&gt; _NSSet</em></strong>ValueAndNotify 调用流程：willChangeValueForKey -&gt; [super setAge:] (Person 的 setter 方法) -&gt; didChangeValueForKey（同时触发 observeValueForKeyPath 监听回调方法，订阅者接收）<br>4&gt; class 方法：重写 class 方法的目的是什么呢？<strong>(lldb) po self.person1.class  输出为：Person</strong>，原来，<strong>苹果粑粑是想要隐藏NSKVONotifying_Person，让开发者无感，使用时与未添加监听时无异</strong><br>5&gt; dealloc方法：释放 KVO 新产生的资源<br>6&gt; _isKVOA方法：标记这个新类 KVO 机制新建的</p>
<p>对<strong>willChangeValueForKey/didChangeValueForKey</strong>还有疑惑的同学可以在 Person.m 中对这两个方法进行重写，再进行调试以变理解。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/深入理解RunLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/深入理解RunLoop/" itemprop="url">
                  深入理解RunLoop
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-04 00:40:46" itemprop="dateCreated datePublished" datetime="2018-09-04T00:40:46+08:00">2018-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:15:59" itemprop="dateModified" datetime="2018-09-11T23:15:59+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3><span id="深入理解runloop">深入理解RunLoop</span></h3><p>什么是 RunLoop，RunLoop的应用范畴，RunLoop内部实现逻辑，RunLoop与线程的关系，timer与RunLoop的关系，RunLoop是怎么响应用户操作的，RunLoop的几种状态，RunLoop的mode作用是什么？</p>
<h4><span id="什么是runloop">什么是RunLoop</span></h4><p>顾名思义，RunLoop是运行循环的意思，就是在程序运行中循环做一些事情。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有runloop，程序执行到这里就结束退出了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 因为有runloop，程序才能保持运行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RunLoop的基本作用：保持程序的持续运行、处理App中的各种事件（eg：触摸事件、定时器事件）、节省CPU资源，提高程序性能：有事做做事，没事做休息</p>
<h4><span id="runloop的应用范畴">RunLoop的应用范畴</span></h4><p>RunLoop主要应用场景有以下几个：<br>1&gt; 定时器（Timer）、performSelector<br>2&gt; GCD Asyc Main Queue<br>3&gt; 事件响应、手势识别、界面刷新<br>4&gt; 网络请求<br>5&gt; AutoreleasePool</p>
<h4><span id="runloop-对象">RunLoop 对象</span></h4><p>iOS中有2套API来访问和使用RunLoop：<br>1&gt; Foundation ： NSRunLoop<br>2&gt; Core Foundation : CFRunLoopRef<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两种获取 RunLoop 方式</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runloop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="built_in">NSRunLoop</span> *mainRunloop = [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runloop2 = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFRunLoopRef</span> mainRunloop2 = <span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure></p>
<p><strong>NSRunLoop</strong>和<strong>CFRunLoopRef</strong>都代表着<strong>RunLoop</strong>对象，NSRunLoop是基于CFRunLoop的一层<strong>OC封装</strong>。</p>
<p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef是开源的，点击查看</a></p>
<h4><span id="runloop与线程">RunLoop与线程</span></h4><p>1&gt; 每条线程都有位移的一个与之对应的RunLoop对象<br>2&gt; RunLoop保存在一个全局的Dictionary，线程作为key，RunLoop作为对象<br>3&gt; 线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建，主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop<br>4&gt; RunLoop会在线程结束时销毁</p>
<h4><span id="源码分析">源码分析</span></h4><p>打开刚才下载的源码，我们发现CF的库是没有xcode项目的。新建一个项目，讲所有文件拖进来。</p>
<p>搜索RunLoop.c文件，CFRunLoopGetMain(void)函数：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFRunLoopRef</span> __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">        <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for "main thread" that always works</span></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果不存在，create</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; <span class="literal">NULL</span> == rlm-&gt;_sources0) &#123;</span><br><span class="line">    ...</span><br><span class="line">    rlm-&gt;_portToV1SourceMap = <span class="built_in">CFDictionaryCreateMutable</span>(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方便理解，省略一些代码，感兴趣的同学可以深入研究</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面调的是_CFRunLoopGet0(pthread_t t)这个函数，内部调用的(CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));，这个函数，根据方法名，我们可以猜测，应该是个字典，传入的参数是一个pthreadPointer线程指针，返回一个runloop对象，也证实了刚才所述的字典管理猜想。</p>
<h4><span id="runloop相关的类">RunLoop相关的类</span></h4><p>Core Foundation中关于RunLoop的5个类<br>1&gt; CFRunLoopRef<br>2&gt; CFRunLoopModeRef<br>3&gt; CFRunLoopSourceRef<br>4&gt; CFRunLoopTimerRef<br>5&gt; CFRunLoopObserverRef</p>
<p>CFRunLoopRef底层结构：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CFRunLoopRef 底层是这种类型结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __CFRunLoop * <span class="built_in">CFRunLoopRef</span>;</span><br></pre></td></tr></table></figure></p>
<p>继续搜索 <strong>struct __CFRunLoop</strong>，会发现搜索出来很多，一个小技巧快速定位，在后面加一个空格和大括号：<strong>struct __CFRunLoop {</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="comment">// 实际结构体成员比这个多，将几个重点的选出：</span></span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="comment">// 当前模式</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="comment">// _models 存储了多个 CFRunLoopModeRef 对象，只有一个为 CurrentMode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们发现一个RunLoop对象里面有一个pthread_t线程，所以每个线程都有一个与之对应的RunLoop；CFMutableSetRef上层与之对应NSMutableSet，与NSMutableArray用法类似，区别是数组有序，可以使用index进行取值；集合无序，取值只能通过[set anyObject]方式。</p>
<h4><span id="cfrunloopmoderef底层结构是什么样子">CFRunLoopModeRef底层结构是什么样子</span></h4><p>跟刚才小技巧一样，我们直接搜索<strong>struct __CFRunLoopMode {</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 同样将本文关心之外的省略</span></span><br><span class="line">    <span class="comment">// mode 名称</span></span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="comment">// _sources0/_sources0 集合存储CFRunLoopSourceRef对象    </span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="comment">// _observers 集合存储 CFRunLoopObserverRef 对象</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="comment">// _timers 存储 CFRunLoopTimerRef 对象</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：</strong><br>1&gt; CFRunLoopModeRef代表着RunLoop的运行模式<br>2&gt; 一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer<br>3&gt; RunLoop启动时只能选择其中一个Mode，作为currentMode<br>4&gt; 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入。这样做的好处是不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响，系统一个时刻只处理一种mode下面的事件<br>5&gt; 如果一个Mode里面没有任何的Source0/Source1/Timer/Observer，RunLoop会立马退出<br>如下图：<br><img src="/2018/09/04/深入理解RunLoop/RunLoop_1.png" alt="RunLoop结构"></p>
<h4><span id="常用的mode">常用的Mode</span></h4><p>1&gt; kCFRunLoopDefaultMode (NSDefaultRunLoopMode)：App默认Mode，通常主线程是在这个Mode下运行</p>
<p>2&gt; UITrackingRunLoopMode：界面跟踪Mode，用于Scrollow追踪触摸滑动，保证界面在滑动时不受其他Mode影响</p>
<p>3&gt; kCFRunLoopCommonModes 通用模式，默认包含上面两种模式</p>
<h4><span id="source0source1timersobvers处理什么事件">Source0/Source1/Timers/Obvers处理什么事件</span></h4><p><img src="/2018/09/04/深入理解RunLoop/RunLoop_2.png" alt="RunLoop结构"><br>断点touchesBegan，打印堆栈，我们发现，时间调用从Source0开始，到最后的touchesBegan</p>
<p>Source0：<br>1&gt; 触摸事件处理<br>2&gt; performSelector:onThread:</p>
<p>Source1:<br>1&gt; 基于Port的线程间通信<br>2&gt; 系统时间捕捉（eg.上面的点击事件虽然最后是Source0处理的，但是最开始其实是Source1来进行捕捉的，然后分发给Source0来进行处理）</p>
<p>Timers：<br>1&gt; NSTimer<br>2&gt; performSelector:withObject:afterDelay:</p>
<p>Observers：<br>1&gt; 用于监听RunLoop的状态<br>2&gt; UI刷新（BeforeWaiting，在休眠之前刷新UI）<br>3&gt; Autorelease pool（BeforeWaiting，休眠之前将池内需要操作的对象进行一次release操作）</p>
<h4><span id="runloop几种状态">RunLoop几种状态</span></h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    <span class="comment">// 即将进入 Loop</span></span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    <span class="comment">// 即将退出 Loop</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>监听 RunLoop 状态：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Observer</span></span><br><span class="line"><span class="meta">#if 1</span></span><br><span class="line">    <span class="comment">// C 函数方式</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, observerRunLoopActivities, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#elif 0</span></span><br><span class="line">    <span class="comment">// block 方式</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    <span class="comment">// 添加 Observer</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> observerRunLoopActivities(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopEntry"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopBeforeTimers"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopBeforeSources"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopBeforeWaiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopAfterWaiting"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopExit"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAllActivities:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"kCFRunLoopAllActivities"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/26/2.OC对象的本质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/26/2.OC对象的本质/" itemprop="url">
                  OC对象的本质（下）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-26 23:05:03" itemprop="dateCreated datePublished" datetime="2018-08-26T23:05:03+08:00">2018-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:17:48" itemprop="dateModified" datetime="2018-09-11T23:17:48+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | OC对象本质 | Objective-C</p>
<p><strong>OC对象的分类，对象的isa指针指向哪里，superClass指针，OC的类信息存放在哪里？</strong> </p>
<p>上篇文章中，我们讲述了一个 NSObject实例对象，Person实例对象的本质，在内存中长什么样子。但是，上篇文章中讲的OC对象的本质，还不包括所有的OC对象。</p>
<h4><span id="1oc对象的分类">1.OC对象的分类</span></h4><p>Objective-C中的对象，简称OC对象，主要可以分为 3 种：</p>
<ul>
<li><strong>instance</strong>对象（<strong>实例</strong>对象）<br><strong>instance</strong>对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *object1 = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSObject</span> *object2 = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/08/26/2.OC对象的本质/OC_1.png" alt="instance对象"><br>1&gt; object1、object2是NSObject的<strong>instance</strong>对象（实例对象）<br>2&gt; 它们是不同的两个对象，分别占据着两块不同的内存<br>3&gt; instance对象在内存中存储信息包括：<strong>isa</strong>指针、其他<strong>成员变量</strong></p>
<ul>
<li><strong>class</strong>对象（<strong>类</strong>对象）<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instance 对象，实例对象</span></span><br><span class="line"><span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 对象，类对象      </span></span><br><span class="line">Class objectClass1 = [object <span class="keyword">class</span>];</span><br><span class="line">Class objectClass2 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">// class 方法返回的一直是class对象，类对象</span></span><br><span class="line"><span class="comment">// Class objectClass2 = [[[[NSObject class] class] class] class];</span></span><br><span class="line">Class objectClass3 = object_getClass(object);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x100444830 0x7fffa5ab9140 0x7fffa5ab9140 0x7fffa5ab9140</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %p %p"</span>, object, objectClass1, objectClass2, objectClass3);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2018/08/26/2.OC对象的本质/OC_2.png" alt="class对象"><br>1&gt; objectClass1~objectClass3都是NSObject的<strong>class</strong>对象（类对象）<br>2&gt; 它们都是同一个对象，每个类在内存中有且只有一个class对象<br>3&gt; class对象在内存中存储的信息主要包括：<strong>isa</strong>指针、<strong>superClass</strong>指针、类的<strong>属性</strong>信息（@property）、类的<strong>实例方法</strong>信息（instance method）、类的<strong>协议</strong>信息（protocol）、类的<strong>成员变量</strong>信息（ivar，这里指的并不是成员变量的值是多少，成员变量的值是实例对象进行存储的，类对象存储的是成员变量的类型、变量名等只需要存储一份的）等…</p>
<ul>
<li><strong>meta-class</strong>对象（<strong>元类</strong>对象）<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 对象，类对象</span></span><br><span class="line">Class objectClass = [object <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// meta-class 对象，元类对象</span></span><br><span class="line"><span class="comment">// 将类对象当做参数传入，获得元类对象;将实例对象当做参数传入，获得的是类对象</span></span><br><span class="line">Class metaClass1 = object_getClass([object <span class="keyword">class</span>]);</span><br><span class="line">Class metaClass2 = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">Class metaClass3 = object_getClass(object_getClass(object));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7fffa5ab90f0 0x7fffa5ab90f0 0x7fffa5ab90f0 0 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p %p %d %d"</span>, metaClass1, metaClass2, metaClass3, class_isMetaClass(objectClass), class_isMetaClass(metaClass1));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>1&gt; objectMetaClass是NSObject的<strong>meta-class</strong>对象（元类对象）<br>2&gt; 每个类在内存中有且只有一个meta-class对象<br>3&gt; <strong>meta-class对象和class对象的内存结构是一样的</strong>（都是 Class 类型），但是用途不一样，在内存中存储的信息主要包括：<strong>isa</strong>指针、<strong>superClass</strong>指针、类的<strong>类方法</strong>信息（class method）、等…<br><img src="/2018/08/26/2.OC对象的本质/OC_3.png" alt="meta-class对象"><br><strong>注意：</strong>为什么说 meta-class 对象和 class 对象结构一样，但是图上画的却不一样呢，因为图上只是将比较重要的一些东西摘了出来，方便理解。其实本质是，class对象类方法信息存储的可能是null空的，meta-class内部属性信息、对象方法信息、协议信息、成员变量信息存储的可能是null空的。</p>
<p><strong>objc_getClass、object_getClass方法区别？</strong><br>本文和上篇文章有用到这几个方法，这几个方法有什么区别呢？<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> look_up_class(aClassName, <span class="literal">NO</span>, <span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果传入instance对象，返回class对象</span></span><br><span class="line">    <span class="comment">// 如果传入class对象，返回meta-class对象</span></span><br><span class="line">    <span class="comment">// 如果传入meta-class对象，返回NSObject的meta-class对象</span></span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码进行分析，objc_getClass传入参数为字符串，根据字符串去Map中取出类对象并返回。 object_getClass传入参数为 id，并且返回值是通过 getIsa 获得，说明返回 isa 指向的类型（即：传入instance对象，返回类对象；传入class对象，返回meta-class对象；传入meta-class对象，返回NSObject的meta-class对象）。</p>
<h4><span id="2isa指针">2.isa指针</span></h4><p>我们发现，OC对象不管是instance对象、类对象还是meta-class都有一个isa指针，那么，isa指针都指向哪里呢，起到了什么作用。</p>
<p>我们都知道，OC对象调用方法是通过消息机制实现的，通过上面的总结我们也知道了实例方法存放在class对象中，类方法存放在meta-class对象中，那么对象是怎么查找到方法并实现调用呢？</p>
<p>这个时候就需要isa指针了，instance对象的isa指针指向class对象，class对象的isa指向meta-class对象，通过isa指针，instance对象、class对象、meta-class对象就可以串起来了，方法调用、以及各种作用就都可以实现了。</p>
<p><img src="/2018/08/26/2.OC对象的本质/OC_4.png" alt="isa指针"></p>
<ul>
<li>instance对象的<strong>isa</strong>指向class对象，当调用<strong>对象方法</strong>时，通过instance对象的<strong>isa</strong>找到class对象，最后找到<strong>对象方法</strong>的实现进行调用</li>
<li>class对象的<strong>isa</strong>指向meta-class对象，当调用<strong>类方法</strong>时，通过class对象的<strong>isa</strong>找到meta-class对象，最后找到<strong>类方法</strong>的实现进行调用</li>
</ul>
<p><strong>注意：</strong>isa指针并不是直接指向对象地址值，还需要逻辑与上一个掩码 <strong>ISA_MASK</strong>，这个了解下就行，如果不了解的话可以直接理解为isa直接指向class对象、meta-class对象。</p>
<h4><span id="superclass指针">superClass指针</span></h4><p>附上一张经典的图：<br><img src="/2018/08/26/2.OC对象的本质/OC_6.png" alt="superClass &amp;&amp; isa"><br><strong>总结如下：</strong></p>
<ul>
<li>instance对象的isa指向class对象</li>
<li>class对象的isa指向meta-class对象</li>
<li>meta-class对象的isa指向基类的meta-class对象</li>
<li>class对象的superClass指向父类的class对象，如果没有父类，superClass指针为nil</li>
<li>meta-class对象的superClass指针指向父类的meta-class对象，基类的meta-class对象的superClass指针指向基类的class对象</li>
<li>instance调用方法的轨迹，isa找到class对象，方法不存在，就通过superClass寻找父类</li>
<li>class调用类方法的轨迹，isa找到meta-class，方法不存在，就通过superClass寻找父类</li>
</ul>
<h4><span id="3窥探-objc_class-结构">3.窥探 objc_class 结构</span></h4><p>类对象与元类对象的结构是一样的，通过都是class类型就可以证明。即 <strong>typedef struct objc_class *Class;</strong> 这个结构体，接下来我们一起来探究下这个结构体内部结构。</p>
<p>我们搞懂这个结构体之后也就可以知道class对象和meta-class对象里面到底放了什么东西了。</p>
<p>点击 objc_class 进入：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<p>进入之后，我们发现，内部如我们想象之中差不多，确实是有 ivars、methodLists、protocols之类的。  </p>
<p><strong>但是，我们发现里面有一个条件编译：#if !<strong>OBJC2</strong></strong>，意思是如果不是 OBJC2 的话才会编译这段代码，现在最新已经是 OC2.0 了，所以，这段代码相当于已经过时了，这个结构体在 OC2.0 时已经不可用了，我们要研究学习的话建议还是参考最新的代码，这个已经研究价值不大了。</p>
<p>打开上篇文章带领大家下载的 <strong>objc4源码</strong>，搜索 struct objc_class， 找到 <strong>objc-runtime-new.h</strong> 中 结构体的最新定义：</p>
<p>我们发现 struct objc_class : objc_object，<strong>结构体也可以继承</strong>，对，没错，这是 C++ 语法，C++ 里面的结构体跟类其实区别不大，基本上卫衣的区别是成员变量默认 public 还是private。C++ 结构体里面还可以定义方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    方便理解，部分与本文讲述联系不大的先省略了，感兴趣的同学可以自行查看</span><br></pre></td></tr></table></figure>
<p>我们可以发现：struct objc_object 结构体内部只有一个 isa 成员以及一些方法。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> setData(class_rw_t *newData) &#123;</span><br><span class="line">        bits.setData(newData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> setInfo(uint32_t set) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;setFlags(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> clearInfo(uint32_t clear) &#123;</span><br><span class="line">        assert(isFuture()  ||  isRealized());</span><br><span class="line">        data()-&gt;clearFlags(clear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    方便理解，部分与本文讲述联系不大的先省略了，感兴趣的同学可以自行查看</span><br></pre></td></tr></table></figure></p>
<p>我们发现其内部有一个 class_rw_t，即可读、可写、table，一个可读可写的表格，而且一些信息都在这个表格里面：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    method_array_t methods;</span><br><span class="line">    property_array_t properties;</span><br><span class="line">    protocol_array_t protocols;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    方便理解，部分与本文讲述联系不大的先省略了，感兴趣的同学可以自行查看</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line">    <span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>总结如下图：</strong><br><img src="/2018/08/26/2.OC对象的本质/OC_7.png" alt="struct objc_class的结构"></p>
<p><strong>总结：</strong> 通过 struct objc_class 内部结构，内部确实有存放 方法、成员变量、协议 的数组，也证明 class对象/meta-class对象 内部确实是如我们所才像一样。对象方法、属性、成员变量、协议信息，存放在class对象中；类方法，存放在meta-class对象中；成员变量的具体值，存放在instance对象中。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/19/1.OC对象的本质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/1.OC对象的本质/" itemprop="url">
                  OC对象的本质（上）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-19 15:10:35" itemprop="dateCreated datePublished" datetime="2018-08-19T15:10:35+08:00">2018-08-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:17:56" itemprop="dateModified" datetime="2018-09-11T23:17:56+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS底层原理/" itemprop="url" rel="index"><span itemprop="name">iOS底层原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>iOS | OC对象本质 | Objective-C</p>
<p><strong>什么是OC语言，OC对象、类的本质是什么，OC对象的内存布局是什么样子的，一个NSObject对象占用多少内存，一个自定义类的对象的本质及占用多少内存？</strong> </p>
<p>万物皆对象，可能是大部分程序员对这个问题的第一反应，再往具体说，可能就不太知道怎么描述了，本文将围绕这几个问题进行展开。</p>
<hr>
<h4><span id="1什么是oc语言">1.什么是OC语言？</span></h4><p>首先我们谈谈什么是做编程语言，编程语言是一种让人们能读懂并且能够展现程序的执行行为的语言，包括语法（正确的表达式以及状态机的使用规则）以及语义（如何去组织这些表达式以及状态机以一种有意义的方式去完成我们的目标）。</p>
<p>我们平时编写的Objective-C代码，底层实现都是C/C++代码，Objective-C的面向对象都是基于C/C++的数据结构实现的。</p>
<p><img src="/2018/08/19/1.OC对象的本质/OC_1.png" alt="OC对象的本质"></p>
<h4><span id="2oc对象-类的本质是什么">2.OC对象、类的本质是什么？</span></h4><blockquote>
<p>OC对象、类是基于C\C++的什么数据结构实现的?</p>
</blockquote>
<p>我们可以将Objective-C代码转换为C\C++代码<br>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件</p>
<p>如果需要链接其他框架，使用-framework参数。比如-framework UIKit</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject Implementation (NSObject 底层实现)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isa 本质就是一个指向 objc_class 结构体的指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，OC对象、类其实是基于C\C++结构体实现的。</p>
<h4><span id="3一个oc对象在内存中是如何布局的">3.一个OC对象在内存中是如何布局的？</span></h4><p>一个OC对象的内存布局入下图所示：<br><img src="/2018/08/19/1.OC对象的本质/OC_2.png" alt="OC对象的本质"></p>
<h4><span id="4一个nsobject对象占用多少内存">4.一个NSObject对象占用多少内存？</span></h4><blockquote>
<p>既然 isa 本质上就是一个指针，一个指针在32位环境下占用4个字节，64位环境下占用8个字节。<strong>一个 NSObject 对象结构体内部就包含一个 isa 指针，那么，我们可以认为一个 NSObject 对象就占用8个字节么？ NO NO NO，虽然表面如此，但是实际上并不是。</strong> </p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 NSObject 实例对象的成员变量所占用的大小 &gt;&gt; 8</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>])); <span class="comment">// 输出为8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 obj 指针所指向内存的大小 &gt;&gt; 16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(obj))); <span class="comment">// 输出为 16</span></span><br></pre></td></tr></table></figure>
<p>我们也可以通过 Xcode -&gt; Debug -&gt; Debug Workflow -&gt; View Memory<br><img src="/2018/08/19/1.OC对象的本质/OC_4.png" alt="View Memory"><br>或者 LLDB 进行查看<br><img src="/2018/08/19/1.OC对象的本质/OC_5.png" alt="LLDB常用指令"></p>
<p>这个是什么意思呢，<strong>其实一个 NSObject 实例对象的大小确实为8个字节，但是系统给其分配的内存其实是16个字节</strong>，接下来我们通过<strong>objc4源码</strong>来探究下到底是为什么。</p>
<blockquote>
<p><strong>objc源码：</strong>  <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a></p>
</blockquote>
<p><img src="/2018/08/19/1.OC对象的本质/OC_3.png" alt="objc源码"><br><a href="/download/1.OC对象的本质/objc4-723.tar.gz"><strong>objc4源码</strong></a></p>
<p>打开下载好的objc4源码，搜索<strong>class_getInstanceSize方法</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们会发现这个方法返回值是<strong>cls-&gt;alignedInstanceSize()</strong>，点进去查看如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"><span class="comment">// 注释意思：返回值成员变量的占用内存大小</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看下 <strong>malloc_size</strong>，由于苹果部分源码不公开，不过不影响今天讨论内容，我们先 <strong>malloc.h</strong> 文件中函数声明：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns size of given ptr */</span></span><br><span class="line"><span class="comment">// 注释意思：返回分配给指针的占用内存大小</span></span><br><span class="line"><span class="keyword">extern</span> size_t malloc_size(<span class="keyword">const</span> <span class="keyword">void</span> *ptr);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>总结</strong>：通过阅读源码，发现一个 NSObject 对象，系统给其分配的空间为 16 个字节，只不过其真正利用起来的只有 8 个字节。</p>
</blockquote>
<p><strong>真的是分配 16 个字节么？</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>上面这行代码，可以发现，创建一个新的实例对象，分为两步：</p>
<blockquote>
<p>alloc：分配一块内存空间<br>init：初始化</p>
</blockquote>
<p>所以，我们想探究实质的话可以从 <strong>alloc</strong> 方法往里面查看，从 <strong>alloc</strong> 开始搜索的话太多了，我们直接从 <strong>allocWithZone</strong> 开始查看，感兴趣的同学可以从 <strong>alloc</strong> 开始进行查看。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAllocWithZone(<span class="keyword">self</span>, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>allocWithZone</strong> 调用的是: <strong>_objc_rootAllocWithZone</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="comment">/* 为了更方便理解，将部分代码省略 */</span></span><br><span class="line">    obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>_objc_rootAllocWithZone</strong> 分配内存空间其实是: <strong>class_createInstance</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续点击进去查看：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line"><span class="keyword">id</span> _class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 为了更方便理解，将部分代码省略 */</span></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，最后调用 C 语言底层的 <strong>calloc</strong> 分配内存函数，我们发现传入了一个 size 参数， size 通过 cls 的 <strong>instanceSize</strong> 函数获得。</p>
<p><strong>嘿，哥们儿，别睡了，重点来了：</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    <span class="comment">// 如果是 NSObject ，下面这行代码相当于 size_t size = 8;</span></span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>通过注释和代码可以发现，<strong>CF：CoreFoundation，硬性规定，返回 size 最小为16</strong>。</p>
<p>这是为什么呢，因为苹果设计 CF 框架，包括我们自己设计一套框架，为了我们的框架能够更好的运行，肯定会做出一些规定、约束，这样就可以理解了。</p>
<p>至于 <strong>word_align</strong>，涉及到 <strong>内存对齐</strong> 概念，下面的的章节也会提到一些，但不会涉及太深，感兴趣的同学可以 Google 相关文档。</p>
</blockquote>
<hr>
<p><strong>接下来，我们可以对这个问题做下总结：</strong></p>
<blockquote>
<p><strong>一个NSObject对象占用多少内存？</strong></p>
<ul>
<li>系统分配了16个字节给 NSObject 对象（通过 malloc_size 函数获得）</li>
<li>但 NSObject 对象内部只使用了8个字节的空间（64bit环境下，可以通过  class_getInstanceSize 函数获得）</li>
</ul>
</blockquote>
<h4><span id="5一个自定义类的对象占用多少内存">5.一个自定义类的对象占用多少内存？</span></h4><p>讲到这里，相信很多小伙伴还是有很多疑问的。刚才只讲了NSObject相关知识。我们平常开发中肯定不会只用NSObject对象，基本上都是我们自定义自己的对象，接下来，来通过两个复杂一点的例子来进行讲解。</p>
<p><strong>（1）自定义一个 Student 类继承 NSObject :</strong><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        stu -&gt; _no = <span class="number">4</span>;</span><br><span class="line">        stu -&gt; _age = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据上文通过 NSObject 实例对象讲解的铺垫，Student 实例对象的本质以及其在内存中布局如下图所示：</p>
<p>Student 实例对象本质：<br><img src="/2018/08/19/1.OC对象的本质/OC_6.png" alt="Student实例对象本质"><br>Student 实例对象内存布局：<br><img src="/2018/08/19/1.OC对象的本质/OC_7.png" alt="Student实例对象内存布局_1"><br>从图中最下面把实例对象 stu 强转成结构体类型 stu2，通过结构体可以正常进行访问，也从另一角度证明 stu 底层结构确实为 Student_IMPL 结构体类型。当然也可以从 View Memory 或者 LLDB 进行证明。</p>
<p>内存布局这样画可能理解更清楚：<br><img src="/2018/08/19/1.OC对象的本质/OC_8.png" alt="Student实例对象内存布局_2"></p>
<p><strong>（2）举一反三，当 Person 继承 NSObject，Student 继承 Person 的情况，一个 Person 对象，一个 Student 对象占用多少内存空间？</strong><br>Student: Person: NSObject：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person_IMPL &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student_IMPL &#123;</span><br><span class="line">    <span class="keyword">struct</span> Person_IMPL Person_IVARS;</span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        stu-&gt;_no = <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"student:%zd, %zd"</span>, class_getInstanceSize([Student <span class="keyword">class</span>]), malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)stu));</span><br><span class="line"></span><br><span class="line">        Person *per = [[Person alloc] init];</span><br><span class="line">        per-&gt;_age = <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"person:%zd, %zd"</span>, class_getInstanceSize([Person <span class="keyword">class</span>]), malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span>*)per));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/08/19/1.OC对象的本质/OC_9.png" alt="Student: Person: NSObject"></p>
<blockquote>
<p><strong>我们先来分析下 Person 实例对象占用多少内存空间：</strong><br>struct NSObject_IMPL NSObject_IVARS；即 isa 占用8个字节，int _age; 占4个字节，那么 Person 实例对象占 8 + 4 = 12 个字节么，错，上文中也有提到，一个 OC 对象至少占用 16 个字节，所以 Person 实例对象占用 16 个字节。</p>
</blockquote>
<p>从另外一个角度，其实还有 <strong>内存对齐</strong> 这个概念，就算是没有 OC对象 至少占用 16 个字节这个规定， Person_IMPL 也占用 16 个字节，<strong>内存对齐有一条规定：结构体的大小比必须是最大成员大小的倍数。</strong> </p>
<p><strong>内存对齐还有很多规定，属于计算机知识范畴，感兴趣的同学可以自行 Google。</strong></p>
<blockquote>
<p><strong>我们再来分析下 Student 实例对象占用多少内存空间：</strong></p>
<ul>
<li>struct Person_IMPL Person_IVARS; 占用 16 个字节，int _no；占用 4 个字节，16 + 4 = 20，而且刚讲了内存对齐规定结构体大小必须是最大成员变量大小的倍数，<strong>那么， Student_IMPL 占用 16 <em> 2 = 32 个字节么？错！结果为 16 </em> 1 = 16 个字节。</strong></li>
<li>为什么呢？<strong>因为 Person_IMPL 虽然分配16个字节，但是实际变量只占用了 12 个字节，还有 4 个字节空出来了</strong>，我们伟大的 iOS 系统会这么傻，白白浪费这 4 个字节的空间么，当然不会，<strong>所以，int _no；其实被放到了 Person_IMPL 空余的 4 个字节空间当中。</strong></li>
</ul>
</blockquote>
<p><strong>malloc_size 我们已经没有太多疑问了，但是可能对 class_getInstanceSize 还存在疑问，class_getInstanceSize 返回 ivar size，即成员变量 size，那么上文 Person instance size 为什么不返回 12 呢？</strong><br>有疑问怎么办，撸源码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size_t class_getInstanceSize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;alignedInstanceSize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过源码可以发现，class_getInstanceSize 实际返回的其实也是  <strong>word_align(unalignedInstanceSize());  内存对齐过的大小。</strong> </p>
<blockquote>
<p><strong>总结</strong>：我们更多的时候其实不需要过多关注 class_getInstanceSize，我们只需要关注 malloc_size 返回的实际分配的内存大小即可。</p>
</blockquote>
<h4><span id="结尾">结尾</span></h4><p>通过今天的讲解，希望可以给一些小伙伴带来帮助，刚开始写博客，排版略乱，还请见谅，文中错误或者不足欢迎指点。</p>
<p><a href="/download/1.OC对象的本质/1.OC对象的本质.zip"><strong>本文demo</strong></a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/18/开篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="小马同学">
      <meta itemprop="description" content="iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小马同学的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/18/开篇/" itemprop="url">
                  开篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-18 17:47:23" itemprop="dateCreated datePublished" datetime="2018-08-18T17:47:23+08:00">2018-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-11 23:17:36" itemprop="dateModified" datetime="2018-09-11T23:17:36+08:00">2018-09-11</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/关于我/" itemprop="url" rel="index"><span itemprop="name">关于我</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="欢迎来到小马同学的技术博客">欢迎来到小马同学的技术博客</span></h1><p>iOS | 技术分享 | 学习交流</p>
<h2><span id="开篇">开篇</span></h2><blockquote>
<p>  Stay hungry. Stay Foolish. - Steve Jobs. 虚心若渴，求知若愚！</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为一位iOS开发工程师，开场当然先要致敬下乔布斯老爷子。Steve Jobs 于2005年6月12号在斯坦福大学的毕业典礼上面的演讲，主要谈及了他人生中的三点感悟:因果、得失、死亡。最后以 “Stay Hungry. Stay Foolish.”总结。</p>
<h2><span id="关于我">关于我</span></h2><p>iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！</p>
<h2><span id="欢迎交流指点并提出宝贵意见">欢迎交流指点并提出宝贵意见</span></h2><ul>
<li>Github：<a href="https://github.com/iStonesy" target="_blank" rel="noopener">@小马同学的Github</a></li>
<li>简书：<a href="https://www.jianshu.com/u/03a336dff0ec" target="_blank" rel="noopener">@小马同学的简书</a></li>
<li>邮箱：<a href="mailto:&#x7a;&#x7a;&#117;&#x6d;&#x61;&#108;&#x65;&#x69;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x7a;&#x7a;&#117;&#x6d;&#x61;&#108;&#x65;&#x69;&#x40;&#49;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a></li>
<li>QQ：492843636</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="小马同学" />
            
              <p class="site-author-name" itemprop="name">小马同学</p>
              <p class="site-description motion-element" itemprop="description">iOS小白一枚，写这个博客，首先是为了总结，通过写作来提高自己的写作和表达能力。其次是想把自己理解的东西分享给大家，与大家进行交流，也希望大家可以指出我的不足并提供宝贵的意见！</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/iStonesy" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:zzumalei@163.coem" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.jianshu.com/u/03a336dff0ec" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i>简书</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小马同学</span>

  

  
</div>








  <div class="theme-info">主题 – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.4.0</div>





<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
<span id="busuanzi_container_site_uv">总访客<span id="busuanzi_value_site_uv"></span>人</span>
<span class="post-meta-divider">|</span>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  

  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
